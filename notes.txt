# impliment the LS-8 emulator
`LDI` - load "immediate", store a value in a register, or "set this register to this value"
`PRN` - a pseudo-instruction that prints the numeric value stored in a register
`HLT` - halt the CPU and exit the emulator


# add constructor to `cpu.py`
add list properties to the CPU class to hold 259 bytes of memory and 8 general-purpose registers
x = [0] * 25  # x is a list of 25 zeroes


# RAM functions
ram_read and ram_write should access the RAM inside the CPU object

`ram_read()` - should accept the address to read and return the value stored there
`ram_write()` - should accept a value to write, and address to write it to


# the core of CPU's run() method
* the most difficult to write
* needs to read the memory address that is stored in register `PC`, and store that result in `IR`, the `Instruction Register`. This can be a local variable in `run()`
* variables `operand_a` and `operand_b`

read that section again when you write the `run()` method ☝️


# HLT instruction
* add `HLT` instruction definition to `cpu.py` so that you can refer it by name instead of numeric value
* in `run()`, exit the loop if a `HLT` instruction is encountered, regardless of whether or not there is more code
* we can consider `HLT` to be similar to pythons `exit()` in that we stop whatever we are doing, wherever we are

# LDI instruction
sets a specific register to a specified value

# PRN instruction 
very similar process to adding `LDI`, the the handler is simplier 


<!-- SPEC -->
# Registers
8 general purpose 8-bit numeric registers R0-R7
* R5 - reserved as the interrupt mask (IM) -- `ignore`
* R6 - reserved as the interrupt status (IS) -- `ignore`
* R7 - reserved as the stack pointer (SP)


# Internal Registers
* PC - Program Counter 
* IR - Instruction Register
* MAR - Memory Address Register
* MDR - Memory Data Register 


# Stack 
the SP points at the value at the top of the stack (most recently pushed) or at address `F4` if the stack is empty

